
--- Start of upload/route.js ---

// src/app/api/research/documents/upload/route.js

import { NextResponse } from 'next/server';
import config from '../../../../../config';
import { pinata } from '../../../../api/file/pinata';

const DOCUMENT_UPLOAD_URL = `${config.backendApiUrl}research/documents/upload_documents/`;
const DOCUMENT_LIST_URL = `${config.backendApiUrl}research/documents/list/`;
const DOCUMENT_DELETE_URL = `${config.backendApiUrl}research/documents/delete`;

async function deleteFile(fileId) {
  try {
      // 0194ae86-c97f-7ae8-a405-f81b7c8fdf3b
    const result = await pinata.files.delete([fileId]);
    console.log("File deleted:", result);
    return result;
  } catch (error) {
    console.error("Error deleting file:", error);
    throw error;
  }
}

export async function POST(request) {
    console.log("[POST] Starting document upload");
     
    try {
        const { files } = await request.json();
        
        if (!files?.length) {
            return NextResponse.json({ 
                status: 'error',
                error: "No files provided" 
            }, { status: 400 });
        }

        console.log(`[POST] Processing ${files.length} files`);
        
        // Process files with Pinata
        const processedFiles = await Promise.all(files.map(async (file) => {
          try {
            console.log(`[POST] Processing file: ${file.file_name}`);
            console.log(`[POST] file url: ${file.file_url}`);
            console.log(`[POST] Processing file data:, ${file}`);
            let fileUrl = '';
            
            if (!file.file_url) {
              const uploadData = await pinata.upload.file(file);
              const signedUrl = await pinata.gateways.createSignedURL({
                cid: uploadData.cid,
                expires: 3600  // 1 hour expiry
              });
        
              fileUrl = signedUrl;
            } else {
              fileUrl = file.file_url;
            }
        
            return {
              file_name: file.file_name,
              file_url: fileUrl,
              file_id: file.file_id,
              file_type: file.file_type,
              file_size: file.file_size
            };
          } catch (error) {
            console.error(`[POST] File processing error: ${file.file_name}`, error);
            throw error;
          }
        }));

        // Filter out failed uploads
        const validFiles = processedFiles.filter(Boolean);
        
        if (validFiles.length === 0) {
            return NextResponse.json({ 
                status: 'error',
                error: "Failed to process uploaded documents" 
            }, { status: 500 });
        }

        const authHeader = request.headers.get('authorization');
        console.log("[POST] Auth header:", authHeader);
        console.log("valid file data: ", JSON.stringify(validFiles))

        // Send to Django backend
        const response = await fetch(DOCUMENT_UPLOAD_URL, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `${authHeader}` },
            credentials: 'include',
            body: JSON.stringify(validFiles)
        });

        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.message || 'Failed to process documents');
        }

        console.log("[POST] Processing complete", data);

        return NextResponse.json({
            status: 'success',
            documents: data.documents,
            processingDetails: {
                totalFiles: validFiles.length,
                totalSize: validFiles.reduce((acc, file) => acc + file.file_size, 0)
            },
            message: `Successfully uploaded ${validFiles.length} documents`
        });

    } catch (error) {
        console.error('[POST] Error:', error);
        return NextResponse.json({ 
            status: 'error',
            error: error.message || 'Failed to upload documents' 
        }, { status: 500 });
    }
}



// Get uploaded documents
export async function GET(request) {
    console.log("[GET] Fetching documents get list ");

    const authHeader = request.headers.get('authorization');
    console.log("[POST] Auth header:", authHeader);
    
    // try {
      const response = await fetch(DOCUMENT_LIST_URL, {
        method: 'GET',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `${authHeader}` },
        credentials: 'include'
      });
     console.log("response: ", response)
      const data = await response.json();
  
      return NextResponse.json({
        status: 'success',
        message: data.message,
        documents: data.documents || []
    });

//   } catch (error) {
//     console.error('[GET] Error:', error);
//     return NextResponse.json({ 
//         status: 'error',
//         error: 'Failed to connect to server'
//     }, { status: 500 });
// }
  
  }


  
export async function DELETE(request) {
  console.log("DELETE ALL FETCH")
  try {
      const data = await request.json();
      const docId = data.document_id;
      const docIds = data.document_ids;  // New field for multiple files

      console.log("[DELETE]: fileId", docId )
      console.log("[DELETE]: fileIds", docIds)

      const authHeader = request.headers.get('authorization');
      
      // Handle single file deletion
      if (docId ) {
          console.log('[DELETE] Attempting to unpin single file:', docId );
          const success = await deleteFile(docId );

          const response = await fetch(DOCUMENT_DELETE_URL, {
            method: 'DELETE',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `${authHeader}` },
            credentials: 'include',
            body: JSON.stringify({ document_id: docId  })
        });
          
          if (!success) {
              throw new Error('Failed to unpin file from Pinata');
          }
          
          return NextResponse.json({
              status: 'success',
              message: 'File unpinned successfully'
          });
      }

      console.log(" [DELETE] file ")
      
      // Handle multiple file deletion
      if (docIds) {
          console.log('[DELETE] Attempting to unpin multiple files:', docIds);
          
          const results = await Promise.all(
            docIds.map(async (id) => {
                  try {
                       await deleteFile(id);
                      
                       console.log("[DELETE] Deleting ID :", id)
                       const response = await fetch(DOCUMENT_DELETE_URL, {
                          method: 'DELETE',
                          headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `${authHeader}` },
                          credentials: 'include',
                          body: JSON.stringify({ document_id: id })
                      });
            


                  } catch (error) {
                      console.error(`Failed to delete file ${id}:`, error);
                      return false;
                  }
              })
          );
          
        const successCount = results.filter(Boolean).length;

          return NextResponse.json({
              status: 'success',
              message: `Successfully removed ${successCount} of ${docIds.length} files`,
              details: {
                  total: docIds.length,
                  successful: successCount,
                  failed: docIds.length - successCount
              }
          });
      }
      
      return NextResponse.json({
          status: 'error',
          error: 'No file id or file ids provided'
      }, { status: 400 });
      
  } catch (error) {
      console.error('[DELETE] Error:', error);
      return NextResponse.json({
          status: 'error',
          error: error.message || 'Failed to unpin file(s)'
      }, { status: 500 });
  }
}



--- End of upload/route.js ---

--- Start of search/route.js ---
// // src/app/api/research/documents/search/route.js


import { NextResponse } from 'next/server';
import config from '../../../../../config';

const DOCUMENT_SEARCH_URL = `${config.backendApiUrl}research/documents/search/`;

export async function POST(request) {
    console.log("[POST] Starting document search");


    try {
        const data = await request.json();
         
        // Validate required fields
        const { document_ids, context, keywords = [] } = data;
        
        const file_name = document_ids
        if (!document_ids?.length) {
            return NextResponse.json({ 
                status: 'error',
                error: "No documents selected for search" 
            }, { status: 400 });
        }

        if (!context?.trim()) {
            return NextResponse.json({ 
                status: 'error',
                error: "Search context is required" 
            }, { status: 400 });
        }

        // Word count validation for context
        const wordCount = context.trim().split(/\s+/).length;
        if (wordCount > 200) {
            return NextResponse.json({ 
                status: 'error',
                error: "Context must be 200 words or less" 
            }, { status: 400 });
        }
        
        const authHeader = request.headers.get('authorization');
        console.log("[POST] Sending Request to backend:", document_ids);
        // Send search request to backend
        const response = await fetch(DOCUMENT_SEARCH_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `${authHeader}` },
            credentials: 'include',
            body: JSON.stringify({
                file_name,
                context: context.trim(),
                keywords: keywords
            })
        });

        const searchResults = await response.json();
        console.log("[POST] SEARCH RESULTS RESPONSE: \n",  searchResults);

        if (!response.ok) {
            throw new Error(searchResults.message || 'Failed to perform search');
        }

        console.log("[POST] Search complete");

        return NextResponse.json({
                        status: 'success',
                        results: searchResults.results.map(result => ({
                            search_results_id: result.search_results_id,
                            document_id: result.document_id,
                            title: result.title,
                            question: result.question,
                            keywords: result.keywords,
                            authors: result.authors,
                            summary: result.summary,
                            relevance_score: result.relevance_score,
                            matching_sections: result.matching_sections.map(section => ({
                                section_id: section.section_id,
                                page_number: section.page_number,
                                start_text: section.start_text,
                                // Map each match type array
                                context_matches: section.context_matches?.map(match => ({
                                    text: match.text,
                                    citations: match.citations || []
                                })) || [],
                                keyword_matches: section.keyword_matches?.map(match => ({
                                    keyword: match.keyword,
                                    text: match.text
                                })) || [],
                                similar_matches: section.similar_matches?.map(match => ({
                                    similar_keyword: match.similar_keyword,
                                    text: match.text
                                })) || [],
                                // Keep any remaining metadata
                                citations: section.citations || []
                            }))
                        })),
                        metadata: {
                            total_results: searchResults.results.length,
                            search_params: {
                                context,
                                keywords,
                                document_count: document_ids.length
                            }
                        }
                    });

    } catch (error) {
        console.error('[POST] Search error:', error);
        return NextResponse.json({ 
            status: 'error',
            error: error.message || 'Failed to perform document search' 
        }, { status: 500 });
    }
}


export async function GET(request) {
    console.log("[GET] Fetching documents search results ");

    const authHeader = request.headers.get('authorization');
    console.log("[GET] Auth header:", authHeader);
    
    // try {
      const response = await fetch(DOCUMENT_SEARCH_URL, {
        method: 'GET',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `${authHeader}` },
        credentials: 'include'
      });
        console.log(" [GET] RESPONSE GET SEARCH: ", response)

        const searchResults = await response.json();
        console.log(' [GET] Search results response: \n', searchResults)

        if (!response.ok) {
            throw new Error(searchResults.message || 'Failed to perform search');
        }

        // const data = await response.json();
        // console.log('[GET] Search results:', data);

        // return NextResponse.json({
        //     status: 'success',
        //     results: data.results,
        //     total_matches: data.total_matches
        // });

        console.log("[GET] Search complete");

        return NextResponse.json({
            status: 'success',
            results: searchResults.results.map(result => ({
                search_results_id: result.search_results_id,
                document_id: result.document_id,
                title: result.title,
                question: result.question,
                keywords: result.keywords,
                authors: result.authors,
                summary: result.summary,
                relevance_score: result.relevance_score,
                matching_sections: result.matching_sections.map(section => ({
                    section_id: section.section_id,
                    page_number: section.page_number,
                    start_text: section.start_text,
                    // Map each match type array
                    context_matches: section.context_matches?.map(match => ({
                        text: match.text,
                        citations: match.citations || []
                    })) || [],
                    keyword_matches: section.keyword_matches?.map(match => ({
                        keyword: match.keyword,
                        text: match.text
                    })) || [],
                    similar_matches: section.similar_matches?.map(match => ({
                        similar_keyword: match.similar_keyword,
                        text: match.text
                    })) || [],
                    // Keep any remaining metadata
                    citations: section.citations || []
                }))
            })),
            metadata: {
                total_results: searchResults.results.length,
                search_params: {
                    context: searchResults.results.question,
                    keywords: searchResults.results.keywords,
                    document_count: searchResults.length
                }
            }
        });
    }


    export async function DELETE(request) {
        console.log("Request Delete Route")
        try {
            const data = await request.json();
            const searchId = data.search_result_id;
            const searchIds = data.search_result_ids;  // New field for multiple files
      
            console.log("[DELETE]: searchId", searchId )
            console.log("[DELETE]: searchIds", searchIds)
      
            const authHeader = request.headers.get('authorization');

             // Handle single file deletion
          if (searchId ) {

            const response = await fetch(DOCUMENT_SEARCH_URL, {
              method: 'DELETE',
              headers: { 
                'Content-Type': 'application/json',
                'Authorization': `${authHeader}` },
              credentials: 'include',
              body: JSON.stringify({ search_result_id: searchId  })
          });
            
            return NextResponse.json({
                status: 'success',
                message: 'Search Results Successfully Deleted'
            });
        }
        if (searchIds) {
            console.log('[DELETE] Attempting to unpin multiple files:', searchIds);
            
            const results = await Promise.all(
                searchIds.map(async (id) => {
                    try {
                         await deleteFile(id);
                        
                         console.log("[DELETE] Deleting ID :", id)
                         const response = await fetch(DOCUMENT_DELETE_URL, {
                            method: 'DELETE',
                            headers: { 
                              'Content-Type': 'application/json',
                              'Authorization': `${authHeader}` },
                            credentials: 'include',
                            body: JSON.stringify({ search_result_id: id })
                        });
              
  
  
                    } catch (error) {
                        console.error(`Failed to delete file ${id}:`, error);
                        return false;
                    }
                })
            );
            
          const successCount = results.filter(Boolean).length;
  
            return NextResponse.json({
                status: 'success',
                message: `Successfully removed ${successCount} of ${searchIds.length} results`,
                details: {
                    total: searchIds.length,
                    successful: successCount,
                    failed: searchIds.length - successCount
                }
            });
        }
        
        return NextResponse.json({
            status: 'error',
            error: 'No result id provided'
        }, { status: 400 });
        
    
        } catch (error) {
            console.error('[DELETE] Search result removal error:', error);
            return NextResponse.json(
                { error: 'Failed to remove search result' },
                { status: 500 }
            );
        }
    }

--- End of search/route.js ---

--- Start of documents/file/route.js ---

// src/app/api/research/documents/file/route.js

import { NextResponse } from 'next/server';
import config from '../../../../../config';
import { pinata, deletePinataFile } from '../../../../api/file/pinata';


async function uploadToPrivateIPFS(file) {
    try {
      const upload = await pinata.upload.file(file, {
        pinataOptions: {
          cidVersion: 1,
        },
        pinataMetadata: {
          name: "My Private File",
        },
      });
      
      console.log("File uploaded to Private IPFS:", upload);
      return upload;
    } catch (error) {
      console.error("Error uploading to Private IPFS:", error);
    }
  }



  async function deleteFile(fileId) {
    try {
        // 0194ae86-c97f-7ae8-a405-f81b7c8fdf3b
      const result = await pinata.files.delete([fileId]);
      console.log("File deleted:", result);
      return result;
    } catch (error) {
      console.error("Error deleting file:", error);
      throw error;
    }
  }


export async function POST(request) {
    console.log("[POST] Starting document upload");
     
    try {
        const formData = await request.formData();
        const files = formData.getAll('files');
        
        if (!files?.length) {
            return NextResponse.json({ 
                status: 'error',
                error: "No files provided" 
            }, { status: 400 });
        }

        console.log(`[POST] Processing ${files.length} files`);
        
        // Process files with Pinata
        const processedFiles = await Promise.all(
            files.map(async (file) => {
                try {
                    console.log(`[POST] Processing: ${file.name}`);
                    // const uploadData = await pinata.upload.file(file);
                    const uploadData = await uploadToPrivateIPFS(file);
                    const signedUrl = await pinata.gateways.createSignedURL({
                        cid: uploadData.cid,
                        expires: 2592000 
                    });
                    console.log("uploadData id :", uploadData.id)
                    return {
                        file_name: file.name,
                        file_url: signedUrl,
                        file_id: uploadData.id,
                        file_type: file.type,
                        file_size: file.size,
                        file_cid: uploadData.cid
                    };
                } catch (error) {
                    console.error(`[POST] File processing error: ${file.name}`, error);
                    return null;
                }
            })
        );

        // Filter out failed uploads
        const validFiles = processedFiles.filter(Boolean);
        
        if (validFiles.length === 0) {
            return NextResponse.json({ 
                status: 'error',
                error: "Failed to process uploaded documents" 
            }, { status: 500 });
        }

        return NextResponse.json({
            status: 'success',
            documents: validFiles,
            message: `Successfully uploaded ${validFiles.length} documents`
        });

    } catch (error) {
        console.error('[POST] Error:', error);
        return NextResponse.json({ 
            status: 'error',
            error: error.message || 'Failed to upload documents' 
        }, { status: 500 });
    }
}




export async function DELETE(request) {
    try {
      const { file_id } = await request.json();
      
      if (!file_id) {
        return NextResponse.json({
          status: 'error',
          error: 'No file id provided'
        }, { status: 400 });
      }
  
      console.log('[DELETE] Attempting to unpin files with file_id:', file_id);
    //   const success = await deletePinataFile(file_id);
    const success =await deleteFile(file_id)
  
      if (!success) {
        throw new Error('Failed to unpin file from Pinata');
      }
  
      return NextResponse.json({
        status: 'success',
        message: 'File unpinned successfully'
      });
  
    } catch (error) {
      console.error('[DELETE] Error:', error);
      return NextResponse.json({
        status: 'error', 
        error: error.message || 'Failed to unpin file'
      }, { status: 500 });
    }
  }
--- End of documents/file/route.js ---

--- Start of research/ResearchAssistant.client.jsx ---
/******************************************************************************
 * RESEARCH ASSISTANT - MAIN CONTAINER COMPONENT
 * // src/app/components/research/ResearchAssistant.client.jsx
 * TEAM GUIDELINES:
 * This file follows a strict organizational structure to maintain scalability
 * and readability. When modifying this component:
 * 1. Group imports by type (React, Components, Services)
 * 2. Add new states to appropriate state management sections
 * 3. Keep related functionality together (document handling, search, etc.)
 * 4. Document data flow with clear comments above each function
 * 5. Use spacing between sections for readability
 * 6. Follow existing error handling patterns
 * 7. Maintain state grouping structure
 * New features should be added to their relevant section with proper documentation
 * and flow comments. If creating a new section, follow the existing format with
 * clear headers and separation.
 *****************************************************************************/


// src/app/components/research/ResearchAssistant.client.jsx
'use client';

/******************************************************************************
 * IMPORTS
 *****************************************************************************/

// React Core
import { useState, useCallback, useEffect } from 'react';


import { DocGraphLogo } from '../svg/DocGraphLogo.client';

// Layout Components
import { ResearchLayout } from './layout/ResearchLayout.client';


// Document Management Components
import { DocumentSidebar } from './DocumentManagement/DocumentSidebar.client';
import { DocumentViewer } from './DocumentViewer/DocumentViewer.client';


// Search Components
import { SearchBar } from './Search/SearchBar.client';

// ToolBar Component
import {ToolbarContainer} from './ToolBar/ToolbarContainer.client'

// UI Components
import { toast } from '../messages/Toast.client';

// Services & Utilities
import { getCache, setCache, clearCache } from '../../services/caches';
import { storageManager } from '../../services/storageManager';

import { useDocumentCache } from '../../hooks/useDocumentCache';
import { useSearchCache } from '../../hooks/useSearchCache';
import { useUICache } from '../../hooks/useUICache';

// User Authentication 
import { useAuth } from '../../hooks/useAuth';

/******************************************************************************
 * TYPE DEFINITIONS
 *****************************************************************************/

/**
 * @typedef {Object} Document
 * @property {string} id - Document identifier
 * @property {string} name - Document name
 * @property {string} url - Document URL
 * @property {string} processing_status - Current processing status
 */

/******************************************************************************
 * COMPONENT: ResearchAssistant
 * 
 * Main container component for the research assistant application.
 * Manages document upload, processing, viewing, and searching functionality.
 * 
 * Data Flow:
 * 1. User uploads documents → Staged → Processed → Available for search
 * 2. Documents can be selected for searching
 * 3. Search results show relevant sections across documents
 *****************************************************************************/

export function ResearchAssistant() {

  /**************************************************************************
   * STATE MANAGEMENT
   **************************************************************************/

  // UI States
  // Controls visibility and processing states for UI elements

  // User Role Management State

  const [userData, setUserData] = useState(); // Processed documents
  

  // Document Management States
  // Handles different states of documents in the system
  const [documents, setDocuments] = useState([]); // Processed documents
  const [openSidebar, setOpenSidebar] = useState(true); // Processed documents
  const [selectedDocuments, setSelectedDocuments] = useState([]); // Selected for search
  const [activeDocument, setActiveDocument] = useState(null); // Currently viewed
  const [stagedDocuments, setStagedDocuments] = useState([]); // Pending upload
  const [isProcessing, setIsProcessing] = useState(false);
  
  // Search & Results States
  // Manages search functionality and results
  const [searchBarVisible, setSearchBarVisible] = useState(false);
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [searchInDocumentResults, setSearchInDocumentResults] = useState({});
 

  // States for Document Status
  const [tabs, setTabs] = useState([]);
  const [activeTab, setActiveTab] = useState(null);

  
  // Toolbar States
   const [activeTool, setActiveTool] = useState(null);
   const [notes, setNotes] = useState([]);




  // Cache 
  // Cache System  Hooks 
  const { cacheDocument, getCachedDocument,cacheStagedDocuments, 
          getCachedStaged, removeCachedStaged, cacheTabDocuments, getCacheTabDocuments, removeCachedTabDocument} = useDocumentCache();
  const { cacheSearchParams, cacheSearchResults, getCachedResults, removeCachedResults } = useSearchCache();
  const { cacheUIPreferences } = useUICache();


  const { user, setUser, loading, error, login, register, logout, checkAuth, updateUser } = useAuth();

  
  /**************************************************************************
   * EFFECTS
   **************************************************************************/

  // Initial Load Effect
  const initializeFromCache = async () => {
    // Restore staged documents
    const staged = await getCachedStaged();
      if (staged) {
        console.log('cache manager: 5', staged )
        setStagedDocuments(staged);
    }
    const cacheTabs = await getCacheTabDocuments();
    if (cacheTabs) {
         console.log("stored tabs:", cacheTabs)
         setTabs(cacheTabs)
    } else {setTabs([])}

  };

  
  // Loadings user documents 
  useEffect( () => {

    const fetchUserData = async () => {
    console.log("User Data:", user);
    console.log("User Data (userData):", userData);

    const savedUser = localStorage.getItem("user");  

    let userDataCookie = await document.cookie
        .split("; ")
        .find(row => row.startsWith("userData="));

    let accessTokenCookie = await document.cookie
        .split("; ")
        .find(row => row.startsWith("accessToken="));

    let refreshTokenCookie = await document.cookie
        .split("; ")
        .find(row => row.startsWith("accessToken="));

    if( accessTokenCookie && refreshTokenCookie) {
      userDataCookie = await JSON.parse(decodeURIComponent(userDataCookie.split("=")[1]));
      accessTokenCookie = await decodeURIComponent(accessTokenCookie.split("=")[1]);  // No JSON.parse()
      refreshTokenCookie = await  decodeURIComponent(refreshTokenCookie.split("=")[1]); // No JSON.parse()
      
      await localStorage.setItem('user', JSON.stringify(userDataCookie));
      await localStorage.setItem('accessToken', accessTokenCookie);
      await localStorage.setItem('refreshToken', refreshTokenCookie );
      console.log("refresh token cookie:", refreshTokenCookie)

    }

   const fetchData = () => {
        fetchDocuments();
        fetchSearchResult();
    };

    if (user) {
        console.log("[ResearchAssistant] Fetching documents for user:", user.email);
        fetchData();
        return;
    }


    if (userDataCookie) {
        // const parsedUserData = JSON.parse(decodeURIComponent(userDataCookie.split("=")[1]));
        await updateUser(userDataCookie);
        await initializeFromCache();
        // updateUser(userDataCookie);

        // Clean up cookie
        document.cookie = "userData=; Max-Age=0; path=/;";

        // Clean up by removing the cookies after reading
        document.cookie = 'userData=; Max-Age=0; path=/;';
        document.cookie = 'accessToken=; Max-Age=0; path=/;';
        document.cookie = 'refreshToken=; Max-Age=0; path=/;';
    } else if (savedUser || userData) {
        console.log("[ResearchAssistant] Fetching documents for saved user or userData:", userData?.email);
        fetchData();
    } else {
        console.log("User not found, resetting state.");
        setUserData("");
        setDocuments([]);
        setTabs([]);
        setSearchResults([]);
        setActiveDocument(null)
        setActiveTab(null)
        // fetchData();
    }
  }
  fetchUserData()
}, [user]);



   // Initial Cache Effect
  //  useEffect(() => {
  //    const initializeFromCache = async () => {
  //     // Restore staged documents
  //     const staged = await getCachedStaged();
  //       if (staged) {
  //         console.log('cache manager: 5', staged )
  //         setStagedDocuments(staged);
  //     }
  //     const cacheTabs = await getCacheTabDocuments();
  //     if (cacheTabs) {
  //          console.log("stored tabs:", cacheTabs)
  //          setTabs(cacheTabs)
  //     } else {setTabs([])}

  //   };

  //   initializeFromCache();
  // }, [getCachedDocument, getCachedStaged, getCacheTabDocuments, getCachedResults]);


  // Search Parameters Cache Effect
  // Restores previous search parameters from cache
  useEffect(() => {
    const cachedSearchParams = getCache('searchParams');
    if (cachedSearchParams) {
      setContext(cachedSearchParams.context || '');
      setKeywords(cachedSearchParams.keywords || []);
    }
  }, []);


  // Search Results Effect
  useEffect(() => {
    if (searchResults?.length > 0) {
      setActiveTool('search-results');
    }
  }, [searchResults]);

  // Document Details Effect
  useEffect(() => {
    if (activeDocument && searchResults?.length < 1 ) {
      setActiveTool('document-details');
    }
  }, [activeDocument, searchResults]);


  useEffect(() => {
    const handleUserChange = (event) => {
      console.log("user data state")
      if(event.detail.user) {
        console.log("user found")
        
        setUserData(event.detail.user)
      } else {
        console.log("user not found")
        setUserData("")
        handleDocumentView([])
        setDocuments([])
        setTabs([])
        setSearchResults([])
        setActiveDocument(null)
        setActiveTab(null)
        
      }
    };
  
    window.addEventListener('userStateChanged', handleUserChange);
    return () => window.removeEventListener('userStateChanged', handleUserChange);
  }, [ ]);


   /**************************************************************************
   * User Role MANAGEMENT
   * Core functionality for handling User activity 
   **************************************************************************/

  const SetAuthUserData = async (userData) => {

    if(userData){
      console.log(" Set User Data {userData}:", userData )
      setUserData(userData)
    }

  }
 

  /**************************************************************************
   * DOCUMENT MANAGEMENT
   * Core functionality for handling document operations
   **************************************************************************/

  /**
   * Fetches processed documents from backend
   * Data Flow: API → documents state → DocumentSidebar
   */
  const fetchDocuments = async () => {
    try {
        setIsProcessing(true);
        const response = await fetch('/api/research/documents/upload', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
            },
        });
        const data = await response.json();

        if (data.status === 'error') {
            console.error('[fetchDocuments] Error:', data.detail); 
            throw new Error(data.message);
        }
    
        // Set documents (might be empty array)
        setDocuments(data.documents);

        // Only show success toast if documents were actually found
        if (data.documents.length > 0) {
            toast.success('Documents loaded successfully');
        } else {
            // Optional: Show informative message for no documents
            console.log('[fetchDocuments] No documents found');
        }
        setIsProcessing(false);
    } catch (error) {
        console.error('[fetchDocuments] Critical error:', error); // Dev logging
    } finally {
        setIsProcessing(false);
    }
};


  const handleUrlSubmit = useCallback(async (url) => {
    try {
      const formData = new FormData();
      formData.append('url', url);

      const response = await fetch('/api/research/documents/url', {
        method: 'POST',
        body: formData
      });

      const data = await response.json();
      if (data.status === 'error') throw new Error(data.error);

      setStagedDocuments(prev => [...prev, data.document]);
      toast.success('Document added from URL');
    } catch (error) {
      console.error('URL submission error:', error);
      toast.error(error.message || 'Failed to add document from URL');
    }
  }, []);

  const handleOpenSidebar = useCallback(async (isOpen) => {
    if(!isOpen){
      setOpenSidebar(true)

     } else {
      setOpenSidebar(false)
     }

  }, []);


  /**************************************************************************
   * PINATA STORAGE INTEGRATION
   * Handles document storage in IPFS via Pinata
   **************************************************************************/

  /**
   * Stores document in Pinata IPFS
   * Flow: File → Pinata → URL Cache → Storage
   */
  const storeToPinata = async (file) => {
    console.log('[ResearchAssistant] Uploading to Pinata:', file.name);
    
    const formData = new FormData();
    formData.append('files', file);

    const response = await fetch('/api/research/documents/file', {
      method: 'POST',
      body: formData
    });

    const data = await response.json();

    if (data.status === 'error') {
      throw new Error(data.error);
    }

    const stagedDocument = data.documents[0];

    return stagedDocument;
  };

  const deleteFromPinata = async (document) => {
    console.log("Document delete:", document)
    let file_id = document.document_id


    console.log('[handleDeleteDocument] Deleting file with fileId:', file_id);
    
    if (file_id) {
      const response = await fetch('/api/research/documents/file', {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ file_id })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to unpin file from Pinata');
      }
    }
  };



  /**************************************************************************
   * DOCUMENT STAGING & UPLOAD HANDLERS
   * Manages document upload workflow
   **************************************************************************/

  /**
   * Handles initial document staging before upload
   * Flow: Files → Staging Area → Upload Queue
   */

  const handleStagedUpload = useCallback(async (files) => {
    console.log('Staging documents:', files);
    setIsProcessing(true);

    const stagedDocuments = [];
    for (const file of files) {
        const stagedDocument = await storeToPinata(file);
        stagedDocuments.push(stagedDocument)
    }

    console.log('All documents staged:', stagedDocuments);
    let newDocs = [];
    await setStagedDocuments(prev => {
      newDocs = [...prev, ...stagedDocuments];
      // Add cache update
      console.log('cache manager: 0-', {newDocs} )
      cacheStagedDocuments(newDocs);
      return newDocs;
    });



    toast.success(`${files.length} document${files.length !== 1 ? 's' : ''} staged`);
    const delayedUpload = async () => {
      await new Promise(resolve => setTimeout(resolve, 1500));
      // createTab(newDocs[0])
      await handleUploadStaged(newDocs);
    };
    
    await delayedUpload();
  }, [cacheStagedDocuments]);



  /**
   * Process all staged documents for upload
   * Flow: Staging → Processing → Upload → Storage
   */

  const handleUploadStaged = useCallback(async (stagedDocuments) => {
    console.log("Upload Staged document!!!:", stagedDocuments)
    if (stagedDocuments.length === 0) return;
    console.log("Number of staged docs:", stagedDocuments.length)
  
    try {
  
      const filesData = stagedDocuments.map(file => ({
        file_name: file.file_name,
        file_url: file.file_url,
        file_id: file.file_id,
        file_type: file.file_type,
        file_size: file.file_size,
        file_cid: file.file_cid,
      }));
  
      console.log('Uploading staged documents:', filesData);

      toast.success(`Now processing documents ...`);
  
      const response = await fetch('/api/research/documents/upload', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
      },
      body: JSON.stringify({ files: filesData })
      });

      
  
      const data = await response.json();
      console.log("data response: ", data)
  
      if (data.status === 'error') {
        setIsProcessing(false);
        console.error('[handleUploadStaged] Upload error:', data.detail); // Dev logging
        throw new Error(data.message);
    }

      
      setIsProcessing(false);
      await setDocuments(prev => [...prev, ...data.documents]);
      await setStagedDocuments([]); // Clear staged documents
      await removeCachedStaged(...data.documents); 

      toast.success(`${data.documents.length} document${data.documents.length !== 1 ? 's' : ''} processed successfully`);
  
    } catch (error) {
      console.error('[handleUploadStaged] Processing error:', error); // Dev logging
      toast.error('Unable to process documents. Please remove the document and try again');
    } finally {
      setIsProcessing(false);
    }
  }, [stagedDocuments]);


  /**
   * Select documents 
   * Flow: 
   */
  
  const handleDocumentSelect = useCallback((documentFileName) => {
    console.log("selected Docs:", documentFileName)
    setSelectedDocuments(documentFileName);
    setSearchBarVisible(documentFileName.length > 0);
    // Cache selection state
    cacheDocument({ type: 'selection', data: documentFileName });
  }, [cacheDocument]);


   /**
   * Removes document 
   * Flow: Staging Area → Remove → Update UI
   */
   const handleRemoveDocument = useCallback(async(document) => {

    if(stagedDocuments){
      setStagedDocuments(prev => 
        prev.filter(file => file.document_id !== document.document_id)
      );
    }
    setDocuments(prev => 
      prev.filter(file => file.document_id !== document.document_id)
    );
    console.log("DETELE DOCUMENT")
    await handleTabClose(document.document_id)
    await setActiveDocument(null);
    await removeCachedStaged(document)
    await deleteFromPinata(document)
    await deleteUploadedDocument(document)
   
  }, []);

  const deleteUploadedDocument = async (document) => {
    console.log("Document uploaded deleted:", document)
    let document_id = document.document_id

    console.log('[handleDeleteDocumentUpload] Deleting document:', document_id);

    if(document.file_id) {
      handleTabClose(document.file_id)
    }
    
    
    if (document_id) {
        try {
            const response = await fetch('/api/research/documents/upload', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
                },
                body: JSON.stringify({ document_id }), // Send single ID
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to delete document');
            }

            toast.success('Document removed successfully', 6000);
          } catch (error) {
            console.error('[handleRemoveDocument] Deletion error:', error); // Dev logging
            toast.error('Unable to remove document. Please try again');
          }
        }
    };



  const handleRemoveAllDocument = async () => {
    console.log("[handleRemoveAllDocument] Starting batch deletion");
    
    console.log("[handleRemoveAllDocument]  Selected Documents: ", selectedDocuments);
    // try {
      const selectedDocs = documents.filter(doc => selectedDocuments.includes(doc.file_name));
      let documentIds = []; 
        selectedDocs.forEach(doc => {
          if (doc.document_id) {
              documentIds.push(doc.document_id);  // Use push instead of append
              handleTabClose(doc.document_id)
              removeCachedStaged(doc)
              deleteFromPinata(doc)
              setDocuments(prev => prev.filter(doc => !documentIds.includes(doc.document_id)));
              setSelectedDocuments(prev => prev.filter(doc => !selectedDocuments.includes(doc.file_name)))
              setActiveDocument(null);
              setActiveTab(null);  
              
          }
      });

      
        console.log("[handleRemoveAllDocument] Remove document Ids: ", documents);
        
        const response = await fetch('/api/research/documents/upload', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
            },
            body: JSON.stringify({ document_ids: documentIds })
        });

        const result = await response.json();
        console.log("[handleRemoveAllDocument] backend response ", result );  
        
        toast.success(`Successfully removed ${selectedDocuments.length} documents`);
        return true;
        

    // } catch (error) {
    //     console.error('[handleRemoveAllDocument] Batch deletion error:', error);
    //     toast.error('Unable to remove documents. Please try again');
    //     return false;
    // }
};


 /**************************************************************************
   * DOCUMENT SELECTION & VIEWING
   * Handles document interaction and viewing functionality
   **************************************************************************/

  /**
   * Handles document selection for search
   * Flow: Selection → Search Visibility → UI Update
   */

  /**
   * Manages document viewing functionality
   * Flow: View Request → Cache Check → Document Display
   */
  const handleDocumentView = useCallback(async (document) => {
    console.log('[ResearchAssistant] Viewing document:', document);
    try {
      let docToView = document
      let tabId;
      // Create new tab or focus existing
      if(document?.document_id) {
        console.log(" [ResearchAssistant] Viewing --Doc")
        tabId = `${document.document_id}`;
      }
      if(document?.file_id) {
        console.log(" [ResearchAssistant] Viewing --File")
        tabId = `${document.file_id}`;
      }
      setSelectedDocuments([document.file_name])
      const existingTab = tabs.find(t => t.id === tabId);
      console.log("all Tabs: ", tabs)
      
      if (existingTab) {
        setActiveTab(tabId);
      } else {
       createTab(document)
      }

     
      console.log('active docuement', {docToView} )
      setActiveDocument(docToView);
      setSearchBarVisible(true);
      
    } catch (error) {
      console.error('[ResearchAssistant] Error viewing document:', error);
      toast.error('Failed to prepare document for viewing');
    }
  }, [tabs]);


  const handleViewSearchResults = useCallback(async (text, document, page) => { 
    console.log("view document search:", document)
    if(text) {
      await handleDocumentView(document)
      await setSearchInDocumentResults({text, page})
    }

  }, [searchInDocumentResults, handleDocumentView]);


  /**************************************************************************
   * TAB MANAGMENT 
   * Manages all our tabs
   **************************************************************************/

  // Tab Management
  const createTab =(document)=>{
    const newTab = {
      id: document?.document_id || document?.file_id,
      title:  document.file_name || document.title,
      type: 'document',
      document: document
    };
    console.log("New tab:", newTab)
    setTabs(prev => {
      cacheTabDocuments([...prev, newTab]);
      return [...prev, newTab];
    })
    setActiveTab(document.document_id);
  
  } 
    
  // Tab Change Handler
  const handleTabChange = useCallback((tabId) => {
    setActiveTab(tabId);
    const tab = tabs.find(t => t.id === tabId);
    if (tab?.document) {
      setActiveDocument(tab.document);
      handleDocumentView(tab.document)
      
    }
  }, [tabs]);


  // Tab Close Handler
  const handleTabClose = useCallback(async(tabId) => {
    console.log("tab remove:", tabId)
    // Remove tab
    setTabs(prev => prev.filter(t => t.id !== tabId));
    await removeCachedTabDocument(tabId)
    

    // If closing active tab
    if (activeTab === tabId) {
      const remainingTabs = tabs.filter(t => t.id !== tabId);
      if (remainingTabs.length > 0) {
        // Switch to last remaining tab
        const lastTab = remainingTabs[remainingTabs.length - 1];
        setActiveTab(lastTab.id);
        setActiveDocument(lastTab.document);
        handleDocumentView(lastTab.document)
      } else {
        // No tabs left
        setActiveTab(null);
        setActiveDocument(null);
      }
    }
  }, [activeTab, tabs]);


/**************************************************************************
   * TOOLBAR FUNCTIONALITY
   * Manages all our tools 
   **************************************************************************/


    // Toolbar Handlers
    const handleToolSelect = useCallback((toolId) => {
      
      if (activeTool === toolId) {
        setActiveTool(null);
      } else {
        setActiveTool(toolId);
      }
        handleSearchBarVisibility(false)
    }, [activeTool]);



  /**************************************************************************
   * SEARCH FUNCTIONALITY
   * Manages document search and result handling
   **************************************************************************/

  const fetchSearchResult = async () => {
    if (!user && !userData) {
        return;
    }
    try {
    setIsSearching(true);
    const cachedResults = await getCachedResults();
    console.log("Get cache search results: ", cachedResults)
    console.log("Get cache search results length: ", cachedResults.data.length)
    if(cachedResults.data > 0) {
      console.log("stored search results:", cachedResults.data)
      setSearchResults(cachedResults.data)
    await setIsSearching(false);  
    } else {
    setIsSearching(true);
    console.log("USER FOUND FETCHING SEARCH RESULTS");

        const response = await fetch('/api/research/documents/search', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
            },
        });
        console.log("Search Response:", response)
        // Check if response is OK (status 200-299)
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        // Check if response has content
        const text = await response.text();
        if (!text) {
            throw new Error("Empty response from server");
        }

        // Parse JSON safely
        const data = JSON.parse(text);
        console.log("FETCH SEARCH RESULTS: ", data);

        setIsSearching(false);

        if (data.status === 'error') {
            throw new Error(data.error);
        }

        // setSearchResults(prev => [...prev, ...data.results]);
        // cacheSearchResults([]);
        cacheSearchResults([...data.results]);
        setSearchResults(data.results)
    }

    } catch (error) {
        console.error('Failed to fetch search results:', error);
        setIsSearching(false);
    }
};



  const handleSearchBarVisibility = useCallback((visible) => {
    setSearchBarVisible(visible);
  }, []);
  

  const handleSearch = useCallback(async (searchParams) => {
    try {
      setIsSearching(true);
      
      // Show toolbar and search results immediately
      setActiveTool('search-results');
      
      const response = await fetch('/api/research/documents/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
         },
        body: JSON.stringify({
          document_ids: selectedDocuments,
          context: searchParams.context,
          keywords: searchParams.keywords
        })
      });

      const data = await response.json();

      if (response.status === 500) {
        console.error('[handleSearch] Search error:', data.detail); // Dev logging
        toast.info('Search timed out, please try again ');
        throw new Error(response.error);
      }

      if (data.results.length === 0) {
        toast.info('No matches found. Try adjusting your search terms', 8000);
      } else {
          toast.success(`Found ${data.results.length} matching result${data.results.length !== 1 ? 's' : ''}`);
      }

      await cacheSearchResults([...searchResults, ...data.results]);
      setSearchResults(prev=> [...prev, ...data.results]);
      toast.success(`Found matches in ${data.results.length} documents`, 6000);

    } catch (error) {
      console.error('[handleSearch] Search failure:', error); // Dev logging
      toast.error('Search failed. Please try again');
      setSearchResults(prev => [...prev]);
    } finally {
        setIsSearching(false);
    }

  }, [selectedDocuments, cacheSearchResults]);



  const handleRemoveSearchResult = useCallback(async (search_results_id) => {
    console.log("Handle remove search result: ", search_results_id)
    let newResults = []
    setSearchResults(prev => {
      newResults = prev.filter(result => 
        
        !(result.search_results_id == search_results_id )
      );
      removeCachedResults(newResults)
      return newResults;
    });
    console.log("Fetch remove search result: ", search_results_id)
    if (search_results_id) {
      // try {
          console.log("Fetch remove search result: Endpoint " )
          const response = await fetch('/api/research/documents/search', {
              method: 'DELETE',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
            },
            body: JSON.stringify({ search_result_id: search_results_id })
        });

          if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error || 'Failed to delete document');
          }

          toast.success('Document removed successfully', 6000);
        // } catch (error) {
        //   console.error('[handleRemoveDocument] Deletion error:', error); // Dev logging
        //   toast.error('Unable to remove document. Please try again');
        // }
      }
  }, []);

  const handleRemoveAllSearchResult = async (selectedSearchResults) => {
    console.log("[handleRemoveAllSearchResult] Starting batch deletion searchResults");
    
    console.log("[handleRemoveAllSearchResult]  Selected Documents: ", selectedSearchResults);
    // try {
      let searchIds = []; 
      selectedSearchResults.forEach(result => {
          if (result.search_result_id) {
            searchIds.push(result.search_result_id); 
          }
      });
      
        console.log("[handleRemoveAllSearchResult] Remove Search IDs: ", searchIds);
        
        const response = await fetch('/api/research/documents/search', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
            },
            body: JSON.stringify({ search_result_ids: searchIds })
        });

        console.log("[handleRemoveAllSearchResult] backend response ", response );

        const result = await response.json();
        console.log("[handleRemoveAllSearchResult]  response OK  ", result );

        return true;
      }

    // } catch (error) {
    //     console.error('[handleRemoveAllDocument] Batch deletion error:', error);
    //     toast.error('Unable to remove documents. Please try again');
    //     return false;
    // }



  /**
   * Clears search results and cached parameters
   * Flow: Clear Request → Reset States → UI Update
   */
  const handleClearSearch = useCallback(() => {
    setSearchResults([]);
    clearCache('searchParams');
  }, []);


  // Note Management
  const handleSaveNote = useCallback((noteData) => {
    const newNote = {
      id: Date.now(),
      ...noteData,
      source: activeDocument?.title || activeDocument?.file_name,
      timestamp: new Date().toISOString()
    };
    setNotes(prev => [...prev, newNote]);
    setActiveTool('notes-list');
  }, [activeDocument]);

  const handleNoteSelect = useCallback((note) => {
    setActiveTool('create-note');
  }, []);


  /**************************************************************************
   * RENDER
   * Component render logic with conditional content display
   **************************************************************************/
  
  

  return (
    <> 
      <ResearchLayout 

        onOpenSidebar={handleOpenSidebar}
        isSidebarOpen={openSidebar}
        tabs={tabs}
        activeTab={activeTab}
        activeTool={activeTool}
        onTabChange={handleTabChange}
        onTabClose={handleTabClose}
        selectedDocuments={selectedDocuments}
        fetchDocs={fetchDocuments}
        setAuthUserData={SetAuthUserData}
        onToggleSearchBarVisibility={handleSearchBarVisibility}


        authState={{
          user,
          loading,
          error, 
          login,
          logout,
          
        }}
        
        // Sidebar Component - Document Management
        sidebarContent={
          <DocumentSidebar
            documents={documents}
            selectedDocuments={selectedDocuments}
            onSelect={handleDocumentSelect}
            onView={handleDocumentView}
            onDelete={handleRemoveDocument}
            onDeleteAll={handleRemoveAllDocument}
            stagedDocuments={stagedDocuments}
            onStagedUpload={handleStagedUpload}
            onUploadStaged={handleUploadStaged}
            onUrlSubmit={handleUrlSubmit}
            isFetchingDocuments={isProcessing}
          />
        }

        // Main Content Area - Dynamic Content Display
        mainContent={
          <div className="relative min-h-full min-w-full border-emerald-600 ">
            {/* Conditional Content Rendering */}
            <DocGraphLogo isAnimating={isProcessing} hasUser={userData} />
            { activeDocument ? (
              // Document Viewer
              <DocumentViewer
                document={activeDocument}

                onClose={() => setActiveDocument(null)}
                searchInResults={searchInDocumentResults}
              />
            ) : (
              // Empty State
              <div className="flex items-center justify-center h-full text-tertiary">
                {/* <NoResults /> */}
                {/* <DocGraphLogo isAnimating={isProcessing} /> */}
              </div>
            )}
          </div>
        }

        // // Search Interface
        searchBarContent={
          <SearchBar
          visible={searchBarVisible}
          onSearch={handleSearch}
          onClose={handleClearSearch}
          selectedDocuments={selectedDocuments}
          onToggleVisibility={handleSearchBarVisibility}
          isSearching={isSearching}
          onSelect={handleDocumentSelect}
        />
        }

        toolbarContent={
          <ToolbarContainer
            documents={documents}
            activeTool={activeTool}
            onToolSelect={handleToolSelect}
            document={activeDocument}
            results={searchResults}
            onSaveNote={handleSaveNote}
            onViewDocument={handleDocumentView}
            onViewSearchResults={handleViewSearchResults}
            notes={notes}
            onNoteSelect={handleNoteSelect}
            isSearching={isSearching}
            onRemoveResult={handleRemoveSearchResult}
            onRemoveAllResult={handleRemoveAllSearchResult}

          />
        }
      


      />

     
    </>
  );
}


export default ResearchAssistant;
--- End of research/ResearchAssistant.client.jsx ---

--- Start of layout/ResearchLayout.client.jsx ---
// src/app/components/research/layout/ResearchLayout.client.jsx
'use client'; 

import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { PanelLeft, PanelRight, X } from 'lucide-react';
import { Header } from '../header/Header.client';
import { AuthModal } from '../../auth/AuthModal';

export function ResearchLayout({ 
  authState,
  sidebarContent,
  onOpenSidebar,
  isSidebarOpen,
  mainContent,
  searchBarContent,
  toolbarContent,
  tabs,
  activeTab,
  activeTool,
  onTabChange,
  onTabClose,
  selectedDocuments,
  fetchDocs,
  setAuthUserData,
  onToggleSearchBarVisibility
}) {
  const [showSidebar, setShowSidebar] = useState(true);
  const [showToolbar, setShowToolbar] = useState(false);


  useEffect(() => {
  // Handle toolbar visibility based on tool selection
  setShowToolbar(!!toolbarContent);
}, [toolbarContent]);


// Add hover timer ref
const hoverTimerRef = useRef(null);
const sidebarRef = useRef(null);

const handleOpenSidebar = (isOpen)=> {
      console.log(" OPEN SIDEBAR--------------------")
      setShowSidebar(isOpen);
      onOpenSidebar(isOpen)
}

// Handle hover effect
const handleMouseEnter = () => {
  if (!showSidebar) {
    hoverTimerRef.current = setTimeout(() => {
      handleOpenSidebar(true)
     
    
    }, 800); // 0.8 second delay
  }
};

const handleMouseLeave = () => {
  if (hoverTimerRef.current) {
    clearTimeout(hoverTimerRef.current);
  }
};

const handleClickOutside =(event)=> {
  if (sidebarRef.current && 
      !sidebarRef.current.contains(event.target) && 
      showSidebar) {
      handleOpenSidebar(false)
  }
}


 


 // Handle clicks outside sidebar

 useEffect(() => {

  document.addEventListener('mousedown', handleClickOutside);
  return () => {
    document.removeEventListener('mousedown', handleClickOutside);
  };
}, [showSidebar, ]);


 useEffect(() => {
  console.log("Open the side bar: User")

  const handleUserChange = (event) => {
    if(event.detail.user) {
      handleOpenSidebar(true)
    }
  };

  window.addEventListener('userStateChanged', handleUserChange);
  return () => window.removeEventListener('userStateChanged', handleUserChange);
}, [ ]);
  

  return (
    <div className="relative left-0 flex flex-col w-full min-w-fit h-screen bg-background  overflow-y-auto">
        {/* Fixed Header with Tabs */}
  <Header
    authState={authState}
    tabs={tabs}
    activeTab={activeTab}
    onTabChange={onTabChange}
    onTabClose={onTabClose}
    selectedDocuments={selectedDocuments}
    fetchDocs={fetchDocs}
    setUserData={setAuthUserData}
    className={` ${showSidebar || activeTool ? "border-b border-tertiary/10" : "" }`}
  />

  {/* Main Content Area - Adjusted for header */}
    <div className="flex flex-1 w-[100%] h-screen overflow-y-hidden ">
        {/* Hover detection area - only show when sidebar is closed */}
        {!showSidebar && (
          <div 
            className="fixed left-2 top-1/2 -translate-y-1/2 w-32 h-full z-50 cursor-pointer"
            onMouseEnter={() => {
              hoverTimerRef.current = setTimeout(() => {
                handleOpenSidebar(true)
              }, 200);
            }}
            onMouseLeave={() => {
              if (hoverTimerRef.current) {
                clearTimeout(hoverTimerRef.current);
              }
            }}
          />
        )}

        {/* Sidebar */}
        <AnimatePresence>
          {showSidebar && (
            <motion.aside
              ref={sidebarRef}
              initial={{ x: -320, opacity: 0 }}
              animate={{ x: 0, opacity: 1 }}
              exit={{ x: -320, opacity: 0 }}
              transition={{ 
                type: "spring",
                stiffness: 250, 
                damping: 30,     
                duration: 0.6 
              }}
              className="shrink-0 h-full w-[320px] border-r border-tertiary/10 z-50 bg-white  relative"
            >
              {showSidebar && (
                <button
                  onClick={() => handleOpenSidebar(true)}
                  className="relative right-[100%] top-0 p-2 pb-4 bg-background/80 
                  hover:bg-tertiary/5 transition-colors z-50 cursor-pointer
                  rounded-lg w-4 h-4 " 
                >
                  <X />
                </button>
            
              )}
              {sidebarContent}
            </motion.aside>
          )}
        </AnimatePresence>

        {/* Main Content */}
        <main 
          className={`
            relative flex-1 h-full w-full
            transition-all duration-300
            ${showSidebar && 'ml-0'}
            ${showToolbar && 'mr-0'}
          `}
        >
          <div className="h-full overflow-y-auto custom-scrollbar">
            {mainContent}
          </div>
          <div className="absolute bottom-0 left-0 right-0">
            {searchBarContent}
          </div>
        </main>

        {/* Right Toolbar */}
        {/* Toolbar */}
        <div className="flex overflow-y-auto">
          {/* Pass through the ToolbarContainer */}
          {toolbarContent}
        </div>

        

        {/* Sidebar Toggle */}
        {!showSidebar && (
          <button
            onClick={() => handleOpenSidebar(true)}
            className="fixed left-0 top-1/2 p-1.5 bg-background/80 
              backdrop-blur-sm border border-tertiary/10 rounded-r-lg
              hover:bg-tertiary/5 transition-colors z-50 cursor-pointer"
          >
            <PanelLeft />
          </button>
        )}

      </div>
    </div>
  );
}





--- End of layout/ResearchLayout.client.jsx ---

--- Start of DocumentManagement/DocumentSidebar.client.jsx ---
// src/app/components/research/DocumentManagement/DocumentSidebar.client.jsx
'use client';

import { useState, useCallback, useEffect } from 'react';
import {  Trash2 } from 'lucide-react';
import { useDropzone } from 'react-dropzone';
import { 
  Upload, Loader2 
} from 'lucide-react';



import { DocumentList } from './DocumentList.client';
import { UrlInput } from './UrlInput.client';
import { DeleteDocumentModal } from './DeleteDocumentModal.client';
import { DocumentDetailsModal } from './DocumentDetailsModal.client';
import {ReferencesModal} from '../ToolBar/ReferenceList.client'
import { toast } from '../../messages/Toast.client';
import { useDocumentCache } from '../../../hooks/useDocumentCache';
import { X } from 'lucide-react'; 


export function DocumentSidebar({
  documents = [],
  selectedDocuments = [],
  stagedDocuments = [],
  onSelect,
  onView,
  onDelete,
  onDeleteAll,
  onStagedUpload,
  isFetchingDocuments,
  onClose  
}) {
  // Existing state
  const [isAllSelected, setIsAllSelected] = useState(false);
  const [deleteDocumentName, setDeleteDocumentName] = useState(null);
  const [documentDetails, setDocumentDetails] = useState(null);

  const [isUploading, setIsUploading] = useState(isFetchingDocuments);

  const {
    cacheDocument,
  } = useDocumentCache();


  // URL submission handler
  const handleUrlSubmit = useCallback(async (url) => {
    try {
      await onStagedUpload([{ url, name: url.split('/').pop() }]);
      toast.success('URL added successfully');
    } catch (error) {
      toast.error('Failed to add URL');
    }
  }, [onStagedUpload]);


  // UPDATE dropzone configuration
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop: async (files) => {
      setIsUploading(true);
      try {
        await onStagedUpload(files);
      } finally {
        setIsUploading(false);
      }
    },
    accept: {
      'application/pdf': ['.pdf'],
      'application/msword': ['.doc'],
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'text/plain': ['.txt']
    },
    maxSize: 50 * 1024 * 1024,
    noClick: true, // Disable click to upload - IMPORTANT
    noDragEventsBubbling: true // Prevent drag events from bubbling
  });

  // handle select all
   const handleSelectAll = useCallback(() => {
    if (isAllSelected) {
      onSelect([]);
      setIsAllSelected(false);
    } else {
      const selectableDocIds = documents
        .filter(doc => doc.processing_status === 'completed')
        .map(doc => doc.file_name);
      onSelect(selectableDocIds);
      setIsAllSelected(true);
    }
  }, [documents, onSelect, isAllSelected]); 

  useEffect(() => {
   
  }, [selectedDocuments]);



  return (
    <div {...getRootProps()} className="flex flex-col pt- h-full ">
      <input {...getInputProps()} />

      {/* URL Input Section */}
      <UrlInput onUrlSubmit={handleUrlSubmit} />
       {/* Upload Area */}
       <div className=" border-b border-tertiary/10">
        <div 
          onClick={() => document.querySelector('input[type="file"]').click()}
          className={`
            border-2 border-dashed border-tertiary/30 rounded-lg p-4
            hover:border-primary/30 transition-colors cursor-pointer
            flex flex-col items-center
            ${isUploading ? 'bg-tertiary/5' : ''}
          `}
        >
          {isUploading && stagedDocuments > 0 ? (
            <>
              <Loader2 className="w-5 h-5 text-primary animate-spin" />
              <p className="text-sm text-tertiary text-center">
                Uploading files...
              </p>
            </>
          ) : (
            <>
              <Upload className="w-5 h-5 text-tertiary" />
              <p className="text-sm text-tertiary text-center">
                Drop files here or <span className="text-primary">browse</span>
              </p>
              <p className="text-xs text-tertiary/70">
                Supports PDF, DOCX, DOC, TXT
              </p>
            </>
          )}
        </div>
      </div>

      {/* Selection Header */}
      {selectedDocuments.length > 0 &&
        <div className="px-4 py-2 border-b border-tertiary/10">
          <div className="flex items-center justify-between">
            <h2 className="text-sm font-medium text-primary">Documents  {selectedDocuments.length > 0 && (<span> Selected: {selectedDocuments.length}</span> )} </h2>
            {documents.length > 0 && (
              <div className='flex' >
                 <button
                  onClick={handleSelectAll}
                  className="text-sm text-tertiary hover:text-primary transition-colors"
                >
                  {isAllSelected ? 'Deselect all' : 'Select all'}
                </button>
                {selectedDocuments.length > 1 &&
                <button
                onClick={onDeleteAll}
                className="text-sm ml-2 text-tertiary hover:text-primary transition-colors  text-red-800"
                >
               <Trash2 className="w-4 h-4" />
              </button>
                }
              
              </div>
             
              
            )}
          </div>
        </div>
        }

      {/* Dropzone Indicator */}
      {isDragActive && (
        <div className="absolute inset-0 z-50 bg-blue-500/10 backdrop-blur-sm 
          border-2 border-blue-500 border-dashed rounded-lg flex items-center justify-center">
          <div className="text-blue-600 font-medium">
            Drop files here...
          </div>
        </div>
      )}

      {/* Document Lists */}
      <DocumentList
        documents={documents}
        stagedDocuments={stagedDocuments}
        isLoading={isUploading}
        selectedDocuments={selectedDocuments}
        onSelect={onSelect}
        onView={onView}
        onDelete={setDeleteDocumentName}
        onDetails={setDocumentDetails}
      />

      {/* Modals */}
      <DeleteDocumentModal
        isOpen={deleteDocumentName !== null}
        onClose={() => setDeleteDocumentName(null)}
        documentName={deleteDocumentName}
        onDeleteDocument={onDelete}
      />

      <DocumentDetailsModal
        isOpen={documentDetails !== null}
        onClose={() => setDocumentDetails(null)}
        document={documentDetails}
      />
    </div>
  );
}






--- End of DocumentManagement/DocumentSidebar.client.jsx ---

--- Start of DocumentManagement/DocumentList.client.jsx ---
// src/app/components/research/DocumentManagement/DocumentList.client.jsx
'use client';



import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FileText,Trash2, Loader2 } from 'lucide-react';
import { DocumentActions } from './DocumentActions.client';


export function DocumentList({
  documents = [],
  stagedDocuments = [],
  isLoading,
  selectedDocuments = [],
  onSelect,
  onView,
  onDelete,
}) {

  return (
    <div className="flex-1 overflow-y-auto custom-scrollbar">
      {/* Staged Documents Section */}
      {stagedDocuments.length > 0 && (
        <div className="border-b border-gray-200">
          <div className="px-4 py-3 bg-gray-50 flex items-center justify-between">
          {stagedDocuments.length > 0 && isLoading ?
            <div className="flex items-center gap-2">
              <h3 className="text-sm font-medium text-gray-900">
                Processing Documents
              </h3>
              <Loader2 className="w-4 h-4 text-primary animate-spin" />
            </div>  :
            <h3 className="text-sm font-medium text-gray-900">
            Staged Documents
            </h3>
          }
          </div>
          <div className="divide-y divide-gray-200">
            {stagedDocuments.map((doc) => (
              <div
                onClick={(e) => {
                  e.stopPropagation();
                  onView(doc);
                }}
              
                key={doc.file_name + doc.file_size}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                className="px-4 py-3 hover:bg-gray-50 transition-colors"
              >
                <div className="flex items-center gap-3">
                  <div className="min-w-0 flex-1">
                    <div className="flex items-center gap-2">
                      <p className="text-sm font-medium text-gray-900 truncate">
                        {doc.title || doc.file_name}
                      </p>
                    </div>
                    <p className="text-xs text-gray-500">
                      {(doc.file_size / (1024 * 1024)).toFixed(2)} MB
                    </p>
                    </div>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onView(doc);
                      }}
                      className="p-1.5 rounded-md text-gray-600 hover:bg-gray-100 transition-colors"
                    >
                      View
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onDelete(doc);
                      }}
                      className="p-1.5 rounded-md text-red-600 hover:bg-red-50 transition-colors"
                    >
                      <Trash2 className="w-4 h-4" />
                    </button>
                  </div>
                </div>
              ))}
          </div>
        </div>
      )}

      {/* Processed Documents */}
      <div className="divide-y divide-gray-200">
          {selectedDocuments.length > 0 && isLoading ?
          <div className="px-4 py-3 bg-gray-50 flex items-center justify-between">
              <div className="flex items-center gap-2">
              <h3 className="text-sm font-medium text-gray-900">
                Documents
                </h3>
            </div>
             </div>  :
           null
          }
    
      {documents.map((doc) => (
          <div
            key={doc.file_name}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            onClick={(e) => {
              e.stopPropagation();
              onView(doc);
            }}
            className={`
              px-4 py-3 
              ${selectedDocuments.includes(doc.file_name) ? 'bg-blue-50' : 'hover:bg-gray-50'} 
              transition-colors
            `}
          >
            <div className="flex items-center gap-3">
              <div className="min-w-0 flex-1">
                <div className="flex items-center justify-between gap-2">
                  <p className="text-sm font-medium text-gray-900 truncate">
                    {doc.title || doc.file_name}
                  </p>
                </div>
                {doc.authors?.length > 0 && (
                  <p className="text-xs text-gray-500 truncate mt-0.5">
                    {doc.authors.join(', ')}
                  </p>
                )}
              </div>
              <DocumentActions
                document={doc}
                isSelected={selectedDocuments.includes(doc.file_name)}
                onView={() => onView(doc)}
                onDelete={() => onDelete(doc)}
                onSelect={() => {
                  if (selectedDocuments.includes(doc.file_name)) {
                    onSelect(selectedDocuments.filter(id => id !== doc.file_name));
                  } else {
                    onSelect([...selectedDocuments, doc.file_name]);
                  }
                }}
              />
            </div>
          </div>
          
        ))}
              

        {/* Empty State */}
        {documents.length === 0 && stagedDocuments.length === 0 && (
          <div className="flex flex-col items-center justify-center py-12 text-center">
            <FileText className="w-12 h-12 text-gray-300 mb-4" />
            <p className="text-sm font-medium text-gray-900">
              No documents yet
            </p>
            <p className="text-xs text-gray-500 mt-1">
              Drop files here or paste a URL to get started
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
--- End of DocumentManagement/DocumentList.client.jsx ---

--- Start of header/TabBar.client.jsx ---
// src/app/components/research/header/TabBar.client.jsx
'use client';

import { useRef, useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { X, ChevronLeft, ChevronRight } from 'lucide-react';

export function TabBar({
  tabs,
  activeTab,
  onTabChange,
  onTabClose,
  selectedDocuments,
}) {
  const scrollRef = useRef(null);
  const [showScrollButtons, setShowScrollButtons] = useState(false);
  console.log("tab selected", selectedDocuments)
  // Check if tabs overflow
  useEffect(() => {
    const checkScroll = () => {
      if (scrollRef.current) {
        const { scrollWidth, clientWidth } = scrollRef.current;
        setShowScrollButtons(scrollWidth > clientWidth);
      }
    };

    checkScroll();
    const resizeObserver = new ResizeObserver(checkScroll);
    if (scrollRef.current) {
      resizeObserver.observe(scrollRef.current);
    }

    return () => resizeObserver.disconnect();
  }, [tabs, selectedDocuments]);

  return (
    <div className="flex-1 flex items-center overflow-hidden">
      {/* Scroll Buttons */}
      {showScrollButtons && (
        <button 
          className="p-1 text-gray-500 hover:text-gray-700 transition-colors"
          onClick={() => {
            scrollRef.current?.scrollBy({ left: -200, behavior: 'smooth' });
          }}
        >
          <ChevronLeft className="w-4 h-4" />
        </button>
      )}

      {/* Tabs */}
      <div 
        ref={scrollRef}
        className="flex-1 ml-5 overflow-hidden flex items-center hide-scrollbar"
      >
        <AnimatePresence mode="popLayout">
          {tabs.map(tab => (
              <motion.div
              key={tab.id}
              layout
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: -20 }}
              onClick={() => onTabChange(tab.id)}
              className={`
                group flex items-center py-8
                rounded-md cursor-pointer transition-colors
                ${activeTab === tab.id 
                  ? 'bg-gray-200 text-gray-800 shadow-sm ' 
                  : selectedDocuments?.some(doc => doc === tab.title)
                    ? 'bg-gray-100 hover:bg-gray-50 border-b-8 border-black' 
                    : 'bg-white text-gray-800 hover:text-gray-800 hover:bg-gray-50'
                }
              `}
            >
              <span className={` px-2  ${activeTab === tab.id ? "text-m font-medium border-b-8 border-primary" : "text-sm font-small " } truncate max-w-[160px]`}>
                {tab.title}
              </span>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onTabClose(tab.id);
                }}
                className="opacity-0 group-hover:opacity-100 
                  p-0.5 rounded-sm cursor-pointer
                  transition-opacity"
              >
                <X className="w-5 h-5 m-1" />
              </button>
            </motion.div>
          ))}
        </AnimatePresence>
      </div>

      {showScrollButtons && (
        <button 
          className="p-1 text-gray-500 hover:text-gray-700 transition-colors"
          onClick={() => {
            scrollRef.current?.scrollBy({ left: 200, behavior: 'smooth' });
          }}
        >
          <ChevronRight className="w-4 h-4" />
        </button>
      )}
    </div>
  );
}
--- End of header/TabBar.client.jsx ---

--- Start of Search/SearchBar.client.jsx ---
// src/app/components/research/Search/SearchBar.client.jsx
'use client';

import { useState, useRef, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {  
  FileText, 
  Tag, 
  X, 
  ChevronDown, 
  ChevronUp,
  Search,
  Loader2,
  Sparkles
} from 'lucide-react';


// Add SparklesCore component for animation
const SparklesCore = ({ className = "" }) => {
  return (
    <div className={`absolute inset-0 ${className}`}>
      <div className="absolute inset-0 bg-gradient-to-r from-primary/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500" />
      <div className="absolute inset-0 bg-primary/5 opacity-0 group-hover:opacity-100 animate-pulse duration-1000" />
    </div>
  );
};

export function SearchBar({
  visible = true,
  onSearch,
  onClose,
  selectedDocuments = [],
  isSearching,
  onToggleVisibility, // Add new prop
  onSelect,
}) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [context, setContext] = useState('');
  const [keywords, setKeywords] = useState([]);
  const [keywordInput, setKeywordInput] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [documentsToSearch, setDocumentsToSearch] = useState([...selectedDocuments]);

  const containerRef = useRef(null);
  const textareaRef = useRef(null);
  const keywordInputRef = useRef(null);

  // Click outside handler
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (containerRef.current && !containerRef.current.contains(event.target)) {
        setIsExpanded(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Auto-resize textarea
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 200)}px`; // Max height of 200px
    }
  
  }, [context]);

  useEffect(() => {
    if(!isSearching) {
      setIsProcessing(false)
    }

  },[isSearching])

  useEffect(() => {
    setDocumentsToSearch([...selectedDocuments])

  },[selectedDocuments])

  // Keyword management
  const addKeyword = useCallback((keyword) => {
    const trimmed = keyword.trim().toLowerCase();
    if (trimmed && !keywords.includes(trimmed)) {
      setKeywords(prev => [...prev, trimmed]);
      setKeywordInput('');
    }
  }, [keywords]);

  const removeKeyword = useCallback((keywordToRemove) => {
    setKeywords(prev => prev.filter(k => k !== keywordToRemove));
  }, []);

  // Search handling
  const handleSubmit = useCallback(() => {
    if (!context.trim()) return;
    
    setIsProcessing(true); // Show loading in search button

    
    const searchParams = {
      context: context.trim(),
      keywords: !keywords || keywords < 1 ? ["No Keywords Provided"] : keywords
    };
  
    onSearch?.(searchParams);
    setIsExpanded(false);
  }, [context, keywords, onSearch]);

  // Clear search
  const handleClear = useCallback(() => {
    setContext('');
    setKeywords([]);
    setKeywordInput('');
    onClose?.();
  }, [onClose]);


if (!visible) {
  return (
    <div className="relative">
      {/* Popup for selected documents */}
          {selectedDocuments.length > 0 && (
      <div className="absolute -top-[0] right-2 mb-2">
        <div className="relative">
          {/* Compact round popup bubble */}
          <div className="
            bg-gradient-to-br from-primary/70 to-primary/80
            text-white px-4 py-4
            rounded-full
            text-xs font-medium
            shadow-[0_4px_12px_rgba(0,0,0,0.08)]
            backdrop-blur-sm
            border border-white/20
            animate-[wiggle_0.6s_ease-in-out,fadeOut_2s_ease-in-out]
          ">
            {/* Compact content */}
            <div className="flex items-center gap-1.5 text-black">
              <span>{selectedDocuments.length} Selected</span>
            </div>
          </div>
        </div>
      </div>
    )}

      {/* Search Button */}
      <button
        onClick={() => onToggleVisibility(true)}
        className={`fixed bottom-10 right-36 
          p-8
          rounded-full 
          bg-white/95
          shadow-[0_8px_30px_rgb(0,0,0,0.06)]
          border border-tertiary/20
          group 
          hover:bg-white
          hover:shadow-[0_20px_50px_rgb(0,0,0,0.12)]
          hover:border-primary/20
          hover:scale-105 
          transition-all duration-500 ease-out z-50
          ${selectedDocuments.length > 0 ? 'animate-[wiggle_1s_ease-in-out] brightness-110' : ''}
        `}
        title={`${selectedDocuments.length} document${selectedDocuments.length !== 1 ? 's' : ''} selected`}
      >
        <div className="relative flex items-center justify-center gap-4">
          <Sparkles 
            className={`absolute w-9 h-9 
              text-primary/10
              ${selectedDocuments.length > 0 ? 'opacity-80' : 'opacity-20'}
              group-hover:opacity-80 
              group-hover:rotate-6
              transition-all duration-500
            `} 
          />
        </div>
      </button>
    </div>
  );
}
  
  return (
    <div ref={containerRef} className="fixed bottom-10 left-1/2 -translate-x-1/2 
      w-full max-w-5xl mx-auto px-4 z-30">
      
      <div className="max-w-5xl mx-auto items-center p-3">
        
        <motion.div
          initial={false}
          animate={{
            height: isExpanded ? 'auto' : '80px',
          }}
          transition={{ duration: 0.2 }}
          className={`
            ${isExpanded ? 'rounded-xl p-5' : 'rounded-full'}
            bg-white border border-tertiary/20 shadow-sm overflow-hidden
            relative group
          `}
        >
           {/* Hide Button */}
        <button
          onClick={() => onToggleVisibility(false)}
          className="absolute top-3 right-3 
            px-3 py-1.5  pt-4
            rounded-full
            bg-background/50 backdrop-blur-sm
            text-tertiary hover:text-primary
            text-m font-medium
            flex items-center gap-1.5
            hover:bg-tertiary/5 hover:border-primary/30
            transition-all duration-200 z-50
            group"
        >
          <span>Hide</span>
        </button>
        




                  {isExpanded && ( 
            <>
              <div className="space-y-4 pt-2">
                {/* Header with guidance */}
                <div className='flex items-center justify-between'>
                  <div className='flex items-center gap-3'>
                    <h3 className="text-sm font-medium text-primary">
                      Search Documents
                    </h3>
                    <div className="flex items-center gap-1.5 px-2.5 py-0.5 
                      bg-primary/5 rounded-full">
                      <div className="w-1.5 h-1.5 rounded-full bg-primary/40" />
                      <span className="text-xs text-primary/70">
                        {documentsToSearch.length} selected
                      </span>
                    </div>
                  </div>
                </div>

                {/* Document Selection Area */}
                <div className={`
                  relative 
                  ${documentsToSearch.length === 0 ? 'bg-tertiary/5' : 'bg-white'}
                  transition-colors duration-300
                `}>
                  {documentsToSearch.length === 0 ? (
                    // Empty State
                    <div className=" p-5 flex flex-col items-center text-center">
                      <div className=" rounded-full bg-tertiary/5 mb-1">
                        <FileText className="w-5 h-5 text-tertiary/50" />
                      </div>
                      <p className="text-sm text-primary/70">
                        Select documents to search through
                      </p>
                      <p className="text-xs text-tertiary max-w-[250px]">
                        {"Click the 'Select' button next to documents in the left sidebar"}
                      </p>
                    </div>
                  ) : ( 
                    // Selected Documents
                    <div className="">
                      <div className="flex flex-wrap gap-2">
                        {documentsToSearch.map((docFileName) => (
                          <div
                            key={docFileName}
                            className="group flex items-center gap-2 
                              pl-3 pr-2 py-1.5 
                              bg-tertiary/5 hover:bg-tertiary/10
                              rounded-full border 
                              hover:border-primary/20
                              transition-all duration-200"
                          >
                            <span className="text-sm text-primary/70 truncate max-w-[180px]">
                              {docFileName}
                            </span>
                            <button
                              onClick={() => {
                                 const updatedDocouments = documentsToSearch.filter(id => id !== docFileName)
                                 setDocumentsToSearch(updatedDocouments)
                                 onSelect(updatedDocouments)
                                 
                              
                              }
                                
                              }
                              className="p-1 rounded-full
                                text-tertiary hover:text-primary
                                hover:bg-white/50
                                transition-colors duration-200"
                              title="Remove from search"
                            >
                              <X className="w-3.5 h-3.5" />
                            </button>
                          </div>
                        ))}
                      </div>

                      {/* Helpful hint */}
                      <div className="my-3 flex items-center gap-2 px-1">
                        <div className="relative flex h-1.5 w-1.5">
                          <span className="animate-ping absolute inline-flex h-full w-full 
                            rounded-full bg-primary/30"></span>
                          <span className="relative inline-flex rounded-full h-1.5 w-1.5 
                            bg-primary/50"></span>
                        </div>
                        <p className="text-xs text-tertiary">
                          Select more documents to expand your search
                        </p>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </>
          )}



          {/* Main Search Input */}
            <div className={`flex items-center w-auto
               ${isExpanded ? 'pb-5'  : 'h-[80px]' }`}>

                {isExpanded ? null : (<button
                  onClick={() => setIsExpanded(!isExpanded)}
                  className=" p-4 rounded-lg hover:bg-tertiary/10 text-tertiary
                    transition-colors"
                >  <Search className="w-6 h-6" />
                </button>
                )}
                <div className={`relative flex hide-scrollbar w-full
                  
                  ${isExpanded  ?  "rounded-xl" :  "rounded-full"} `}>
                  <textarea
                    ref={textareaRef}
                    value={context}
                    onChange={(e) => {
                      setContext(e.target.value);
                      // Auto-resize
                      e.target.style.height = 'inherit';
                      e.target.style.height = `${e.target.scrollHeight}px`;
                    }}
                    onFocus={() => setIsExpanded(true)}
                    onClick={() => setIsExpanded(true)}
                    placeholder="Enter your research query to search the papaer..."
                    className={`
                      ${isExpanded  ? 'min-h-[160px] p-3  border-2'
                        : 'min-h-[100px] flex items-center justify-center border-none relative top-3 p-3 pt-10 ' } 
                      w-full bg-white text-primary rounded-xl
                      
                       border-tertiary/20 
                      placeholder:text-tertiary/50 
                      focus:outline-none focus:border-primary/30 focus:ring-2 
                      focus:ring-primary/20 
                      
                      transition-all duration-200 
                  
                      hover:border-primary/30 hide-scrollbar`}
                    style={{
                      minHeight: '80px',
                      maxHeight: '400px'
                    }}
                  />

                  {/* Character Count */}
                  {context.length > 0 && (
                    <div className="absolute bottom-2 right-4 px-2 pt-3 
                      bg-background/80 rounded-md text-xs text-tertiary 
                      backdrop-blur-sm "
                    >
                      {context.length}/2000 characters
                    </div>
                  )}
                    
                </div>
              
          </div>

         {/* Expanded Content */}
         <AnimatePresence>
            {isExpanded && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: 0.2 }}
                className=" border-tertiary/10"
              >
                
                  {/* Right Column - Keywords */}
                  
                    <h3 className="text-sm font-medium text-primary flex items-center gap-2">
                      <Tag className="w-4 h-4" />
                      Keywords
                    </h3>
                    <div className="bg-tertiary/5 rounded-lg p-3">
                      <div className="flex flex-wrap gap-2">
                        {keywords.map((keyword) => (
                          <span
                            key={keyword}
                            className="inline-flex items-center gap-1 px-3 py-1 rounded-full 
                              bg-primary/10 text-primary text-sm hover:bg-primary/20 transition-colors"
                          >
                            {keyword}
                            <button
                              onClick={() => removeKeyword(keyword)}
                              className="p-0.5 hover:bg-primary/20 rounded-full"
                            >
                              <X className="w-3 h-3" />
                            </button>
                          </span>
                        ))}
                        <input
                          ref={keywordInputRef}
                          type="text"
                          value={keywordInput}
                          onChange={(e) => setKeywordInput(e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter' && keywordInput.trim()) {
                              addKeyword(keywordInput);
                            }
                          }}
                          placeholder={keywords.length === 0 ? "Add keywords..." : ""}
                          className="flex-1 min-w-[150px] px-2 py-1 bg-transparent text-primary 
                            placeholder:text-tertiary/60 focus:outline-none text-sm"
                        />
                      </div>
                    </div>

                {/* Action Bar */}
                <div className=" bg-tertiary/5 border-tertiary/10 
                  flex items-center justify-between">
                  <p className="text-xs text-tertiary flex items-center gap-1">
                    Press <span className="font-medium px-1 py-0.5 bg-tertiary/10 rounded-md">⏎ Enter</span> 
                    to add keywords
                  </p>
                  <div className="flex items-center gap-3">
                    <button
                      onClick={handleClear}
                      className="px-2 py-2 text-sm text-tertiary hover:text-primary 
                        hover:bg-tertiary/10 rounded-lg transition-colors"
                    >
                      Clear All
                    </button>
                    <button
                      onClick={handleSubmit}
                      disabled={!context.trim() || isProcessing}
                      className="px-6 py-2.5 text-sm font-medium
                          bg-gradient-to-b from-gray-50 to-gray-100
                          text-gray-900 rounded-lg
                          border border-gray-200
                          shadow-sm 
                          hover:bg-gray-100 hover:border-gray-300 hover:translate-y-[1px]
                          active:bg-gray-200 active:translate-y-[2px]
                          disabled:opacity-50 disabled:cursor-not-allowed 
                          disabled:hover:translate-y-0
                          transition-all duration-150 ease-in-out
                          flex items-center gap-2 overflow-hidden "
                    >
                      {isProcessing ? (
                        <>
                          <Loader2 className="w-4 h-4 animate-spin" />
                        </>
                      ) : (
                        <>
                          <Sparkles className="w-4 h-4" />
                          Search
                        </>
                      )}
                    </button>
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </motion.div>
      </div>
    </div>
        
    
  )
  
  }
--- End of Search/SearchBar.client.jsx ---

--- Start of ToolbarContainer.client.jsx ---


// src/app/components/research/layout/ToolbarContainer.client.jsx
'use client';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Sparkles,
  FileText, 
  BookOpen, 
  ListTodo,
  PlusSquare,
  PanelLeft,
  ArrowLeftFromLine, 
  ArrowRightFromLine,
  X
} from 'lucide-react';

// Import tool components
import { SearchResults } from './SearchResults.client';
import { DocumentDetails } from './DocumentDetails.client';
import { ReferenceList } from './ReferenceList.client';
import { NotesList } from './NoteList.client';
import { NoteCreator } from './NoteCreator.client';

// Tool definitions with fixed types
const tools = [
  { id: 'search-results', icon: Sparkles, label: 'Search Results' },
  { id: 'document-details', icon: FileText, label: 'Document Details' },
  { id: 'references', icon: BookOpen, label: 'References' },
  { id: 'notes-list', icon: ListTodo, label: 'Notes' },
  { id: 'create-note', icon: PlusSquare, label: 'Create Note' }
];

export function ToolbarContainer({ 
  documents,
  activeTool, 
  onToolSelect, 
  document,
  results,
  onToggleSearchBarVisibility,
  onSaveNote,
  onViewDocument,
  onViewSearchResults,
  notes,
  onNoteSelect,
  isSearching,
  onRemoveResult,
  onRemoveAllResult,
  onClose,
}) {
  const [isExpanded, setIsExpanded] = useState(false);
  // Determine tool visibility based on available data
  const toolVisibility = {
    'search-results': results || activeTool == 'search-results' || true ,
    'document-details': !!document,
    'references': !!(document?.references?.entries),
    'notes-list': true,
    'create-note': true
  };

  // Get content for active tool
  const getToolContent = () => {
    switch(activeTool) {
      case 'search-results':
        return (
          <SearchResults 
            documents={documents}
            results={results}

            onSaveNote={onSaveNote}
            onViewDocument={onViewDocument}
            onViewSearchResults={onViewSearchResults}
            isLoading={isSearching}
            onRemoveResult={onRemoveResult}
            onRemoveAllResult={onRemoveAllResult}
            isToolbarExpanded={isExpanded}
          />
        );
      case 'document-details':
        return <DocumentDetails document={document} onToolSelect={onToolSelect} />;
      case 'references':
        return <ReferenceList document={document} />;
      case 'notes-list':
        return <NotesList notes={notes} onNoteSelect={onNoteSelect} />;
      case 'create-note':
        return <NoteCreator onSave={onSaveNote} />;
      default:
        return null;
    }
  };

  return (
    <div className="flex w-auto  overflow-y-hidden overflow-x-hidden">
      
      {/* Tool Content Area */}
      <AnimatePresence mode="wait">
      <div className={`flex-1 relative mr-2 
        ${activeTool 
          ? isExpanded 
            ? 'w-[700px] min-w-[400px]  pl-6 border-l' 
            : 'w-[400px] min-w-[300px]  pl-6 border-l' 
          : 'w-[0px] pr-0'
        } 
        custom-scrollbar overflow-x-hidden transition-all duration-300`}
      >
        <motion.div
          key={activeTool}
          initial={{ opacity: 0, x: 320 }}
          animate={{ opacity: 1, x: 0 }}
          exit={{ opacity: 0, x: 320 }}
          transition={{ 
            type: "spring",
            stiffness: 250,
            damping: 30,
            duration: 0.6 
          }}
          className="overflow-x-hidden"
        >
            {activeTool && 
            <div className="flex items-center gap-1 relative ">
              {/* Expand Button */}
              <button
                onClick={() => setIsExpanded(!isExpanded)}
                className="p-1.5 rounded-lg 
                  text-tertiary hover:text-primary hover:bg-tertiary/5 
                  transition-colors"
              >
                {isExpanded ? <ArrowRightFromLine className="w-6 h-6" /> : <ArrowLeftFromLine className="w-6 h-6" />}
              </button>
              {/* Close Button */}
              <button
                onClick={() => onToolSelect(null)}
                className="p-1.5 rounded-lg 
                  text-tertiary hover:text-primary hover:bg-tertiary/5 
                  transition-colors "
              >
                <X className="w-6 h-6" />
              </button>
            </div>
          }
          {getToolContent()}
        </motion.div>
      </div>
    </AnimatePresence>

      {/* Tool Icons */}
      <div className="w-16 relative right-2 h-full px-8 bg-tertiary/5 ">
        <div className="flex flex-col items-center py-4 gap-4">
          {tools.map(tool => {
            const Icon = tool.icon;
            if (!toolVisibility[tool.id]) return null;

            return (
              <button
                key={tool.id}
                onClick={() => onToolSelect(tool.id)}
                className={`
                  relative p-3 rounded-2xl transition-all 
                  ${activeTool === tool.id 
                    ? 'bg-primary/10 bg-gray-200 text-primary scale-120' // Added scale effect
                    : 'text-tertiary hover:text-primary hover:bg-tertiary/5'
                  }
                `}
                title={tool.label}
              >
                <Icon className="w-6 h-6" />
                {tool.id === 'search-results' && results?.length > 0 && (
                  <span className="absolute -top-1 -right-1 w-4 h-4 bg-primary 
                    rounded-full flex items-center justify-center">
                    <span className="text-[10px] font-medium text-white">
                      {results.length}
                    </span>
                  </span>
                )}
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
}



--- End of ToolbarContainer.client.jsx ---

File not found: Toolbar/SearchResults.client.jsx
